{"ts":1348066596492,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\n\n#include <assert.h>\n#include <errno.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include <sys/socket.h>\n\n#include \"cmd.h\"\n#include \"proc.h\"\n#include \"spawn.h\"\n\n\nstatic int read_bytes(int fd, void* buf, size_t bytes_needed) {\n  size_t bytes_read = 0;\n  \n  while (bytes_read < bytes_needed) {\n    int r = read(fd, (char*) buf + bytes_read, bytes_needed - bytes_read);\n\n    if (r > 0)\n      bytes_read += r;\n\n    if (r == 0 ||\n        (r < 0 && errno != EINTR))\n      return -1;\n  }\n  \n  return bytes_read;\n}\n\n\nstatic char* read_string(int fd) {\n  uint32_t len;\n  char* s;\n  \n  if (read_bytes(fd, &len, sizeof len) < 0)\n    return NULL;\n    \n  s = malloc(len + 1);\n  if (s == NULL)\n    return NULL;\n  \n  if (read_bytes(fd, s, len) < 0) {\n    free(s);\n    return NULL;\n  }\n  \n  s[len] = '\\0';\n\n  return s;\n}\n\n\nstatic int write_bytes(int fd, void* buf, size_t bytes_to_write) {\n  size_t bytes_written = 0;\n  \n  while (bytes_written < bytes_to_write) {\n    int r = write(fd, (char*) buf + bytes_written, bytes_to_write - bytes_written);\n\n    if (r > 0)\n      bytes_written += r;\n\n    if (r == 0 ||\n        (r < 0 && errno != EINTR))\n      return -1;\n  }\n  \n  return bytes_written;\n}\n\n\nstatic int rjs_start_cmd(int fd) {\n  rjs_process_t* p;\n  int pid;\n  \n  p = rjs_proc_alloc(sizeof *p);\n  if (p == NULL)\n    return -1;\n   \n  memset(p, 0, sizeof *p);\n    \n  p->tag = read_string(fd);\n  if (p->tag == NULL)\n    goto err;\n    \n  p->file = read_string(fd);\n  if (p->file == NULL)\n    goto err;\n\n  p->args = read_string(fd);\n  if (p->args == NULL)\n    goto err;   \n    \n  p->env = read_string(fd);\n  if (p->env == NULL)\n    goto err;\n    \n  pid = spawn(p->file, p->args, p->env, 1);\n  if (pid < 0)\n    pid = -errno;\n    \n  pid = rjs_proc_start(p);\n  if (pid < 0)\n    goto err;\n    \n  write_bytes(fd, &pid, sizeof pid);\n  return 0;\n  \n err:\n  rjs_proc_free(p);\n  return -1;\n}\n\n\nstatic void rjs_invalid_cmd(int fd, int err) {\n  int32_t val;\n  \n  assert(err > 0);\n    \n  val = -err;\n  write_bytes(fd, &val, sizeof val);\n}\n\n\nint rjs_process_cmd(int server_fd) {\n  int fd;\n  uint32_t cmd_type;\n  \n  fd = accept(server_fd, NULL, NULL); \n  if (fd < 0)\n    return -1;\n\n  if (read_bytes(fd, &cmd_type, sizeof cmd_type) < 0) {\n    rjs_invalid_cmd(fd, EINVAL);\n    goto out;\n  }\n\n  switch (cmd_type) {\n#define CMD_CASE(utype, ltype) \\\n  case RJS_##utype: \\\n    rjs_##ltype##_cmd(fd); \\\n    break; \n    CMD_CASE(START, start)\n    //CMD_CASE(STOP, stop)\n    //CMD_CASE(QUERY, query)\n    //CMD_CASE(LIST, list)\n#undef CMD_CASE\n    default:\n      rjs_invalid_cmd(fd, ENOSYS);\n  }\n  \n out:\n  close(fd);\n  return 0;\n}\n\n\n\n"]],"start1":0,"start2":0,"length1":0,"length2":2635}]],"length":2635}
