{"ts":1348088062565,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\n#include <assert.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nextern char** environ;\nstatic int null_fd = -1;\n\n\n/* For the sake of convenience, args and env are compressed into a single string. */\n/* This function expands them to a list of pointers. */\nstatic char** expand_string(char* s) {\n  size_t num_strings, index, offset;\n  char new_string;\n  char** list;\n  \n  num_strings = 0;\n\n  for (new_string = 1, offset = 0; ; offset++) {\n    if (new_string) {\n      if (s[offset] == '\\0')\n        break;\n      num_strings++;\n      new_string = 0;\n    } else {\n      if (s[offset] == '\\0')\n        new_string = 1; \n    }\n  }\n  \n  list = calloc(sizeof(char*), num_strings + 1);\n  if (list == NULL)\n    return NULL;\n\n  index = 0;    \n  for (new_string = 1, offset = 0; ; offset++) {\n    if (new_string) {\n      if (s[offset] == '\\0')\n        break;\n      assert(index <= num_strings);\n      list[index++] = s + offset;\n      new_string = 0;\n    } else {\n      if (s[offset] == '\\0')\n        new_string = 1;\n    }\n  }\n    \n  return list;    \n}\n\n\nstatic int get_null_fd() {\n  int fd;\n  \n  if (null_fd != -1)\n    return null_fd;\n  \n  fd = open(\"/dev/null\", O_RDONLY, 0);\n  if (fd < 0)\n    return -1;\n    \n  if (ioctl(fd, FIOCLEX, NULL) < 0) {\n    close(fd);\n    return -1;\n  }\n\n  null_fd = fd;\n  return fd;\n}\n\n\nint rjs_spawn(char* file, char* args, char* env, int outfd) {\n  int err_fds[2] = { -1, -1 };\n  pid_t child_pid = 0;\n  int spawn_error, r;\n  size_t bytes_read;\n    \n  if (pipe(err_fds) < 0)\n    goto error;\n        \n  child_pid = fork();\n  if (child_pid < 0)\n    goto error;\n    \n  if (child_pid == 0) {   \n    /* We are the child. */\n    char** argv;\n    int e;\n\n    close(err_fds[0]);\n    \n    if (ioctl(err_fds[1], FIOCLEX, NULL) < 0)\n      goto error;\n    \n    if (dup2(get_null_fd(), 0) < 0)\n      goto child_error;\n     \n    if (dup2(outfd, 1) < 0)\n      goto child_error;\n      \n    if (dup2(outfd, 2) < 0)\n      goto child_error;\n    \n    argv = expand_string(args);\n    if (argv == NULL)\n      goto child_error;\n\n    environ = expand_string(env);\n    if (environ == NULL)\n      goto child_error;\n      \n    execvp(file, argv);\n\n   child_error:\n    e = errno;\n    write(err_fds[1], &e, sizeof e);\n    exit(127);\n  }\n  \n  close(err_fds[1]);\n  err_fds[1] = -1;\n  \n  spawn_error = 0;\n  bytes_read = 0;\n  \n  while (bytes_read < sizeof spawn_error) {\n    r = read(err_fds[0],\n             bytes_read + (char*) &spawn_error, \n             sizeof spawn_error - bytes_read);\n    if (r == -1 && errno == EINTR)\n      continue;\n    if (r == -1)\n      goto error;\n    if (r == 0)\n      break;\n    bytes_read += r;\n  }\n  \n  if (bytes_read == 4) {\n    errno = spawn_error;\n    goto error;\n  }\n  \n  if (r != 0)\n    goto error;\n  \n  close(err_fds[0]);\n  return child_pid;    \n\n error: {\n    int saved_errno = errno;\n  \n    if (err_fds[0] != -1)\n      close(err_fds[0]);\n    if (err_fds[1] != -1)\n      close(err_fds[1]);\n    if (child_pid > 0)\n      kill(-child_pid, SIGKILL);\n\n    errno = saved_errno;\n    return -1;  \n  }\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":3166}]],"length":3166}
{"contributors":[],"silentsave":false,"ts":1352229019161,"patch":[[{"diffs":[[0,";\n\n\n"],[-1,"/* For the sake of convenience, args and env are compressed into a single string. */\n/* This function expands them to a list of pointers. */\nstatic char** expand_string(char* s) {\n  size_t num_strings, index, offset;\n  char new_string;\n  char** list;\n  \n  num_strings = 0;\n\n  for (new_string = 1, offset = 0; ; offset++) {\n    if (new_string) {\n      if (s[offset] == '\\0')\n        break;\n      num_strings++;\n      new_string = 0;\n    } else {\n      if (s[offset] == '\\0')\n        new_string = 1; \n    }\n  }\n  \n  list = calloc(sizeof(char*), num_strings + 1);\n  if (list == NULL)\n    return NULL;\n\n  index = 0;    \n  for (new_string = 1, offset = 0; ; offset++) {\n    if (new_string) {\n      if (s[offset] == '\\0')\n        break;\n      assert(index <= num_strings);\n      list[index++] = s + offset;\n      new_string = 0;\n    } else {\n      if (s[offset] == '\\0')\n        new_string = 1;\n    }\n  }\n    \n  return list;    \n}\n\n\n"],[0,"stat"]],"start1":255,"start2":255,"length1":935,"length2":8},{"diffs":[[0,"ar* args"],[1,"[]"],[0,", char* "]],"start1":550,"start2":550,"length1":16,"length2":18},{"diffs":[[0,"har* env"],[1,"[]"],[0,", int ou"]],"start1":563,"start2":563,"length1":16,"length2":18}]],"length":2243,"saved":false}
{"ts":1352229065812,"patch":[[{"diffs":[[0,"int "],[-1,"rjs"],[1,"do"],[0,"_spa"]],"start1":522,"start2":522,"length1":11,"length2":10}]],"length":2242,"saved":false}
{"ts":1352229229770,"patch":[[{"diffs":[[0,"* env[],"],[1," char* cwd,"],[0," int out"]],"start1":565,"start2":565,"length1":16,"length2":27}]],"length":2253,"saved":false}
{"ts":1352229266715,"patch":[[{"diffs":[[0,"har* arg"],[-1,"s"],[1,"v"],[0,"[], char"]],"start1":548,"start2":548,"length1":17,"length2":17},{"diffs":[[0,"har* env"],[1,"v"],[0,"[], char"]],"start1":562,"start2":562,"length1":16,"length2":17}]],"length":2254,"saved":false}
{"ts":1352229298790,"patch":[[{"diffs":[[0,"    "],[-1,"argv = expand_string(args);\n    if (argv == NULL"],[1,"if (chdir(cwd) < 0"],[0,")\n  "]],"start1":1178,"start2":1178,"length1":56,"length2":26},{"diffs":[[0,"or;\n"],[-1,"\n"],[0,"    "],[-1,"environ = expand_string(env);"],[0,"\n    "],[-1,"if ("],[1,"*"],[0,"envi"]],"start1":1222,"start2":1222,"length1":51,"length2":18},{"diffs":[[0,"on ="],[-1,"= NULL)\n      goto child_error;\n      "],[1," env;\n"],[0,"\n   "]],"start1":1241,"start2":1241,"length1":46,"length2":14}]],"length":2159,"saved":false}
{"contributors":[],"silentsave":false,"ts":1352232996605,"patch":[[{"diffs":[[0,"on = env"],[1,"v"],[0,";\n\n    e"]],"start1":1241,"start2":1241,"length1":16,"length2":17}]],"length":2160,"saved":false}
{"ts":1352233026953,"patch":[[{"diffs":[[0," */\n"],[-1,"    char** argv;\n"],[0,"    "]],"start1":866,"start2":866,"length1":25,"length2":8}]],"length":2143,"saved":false}
{"ts":1352233103513,"patch":[[{"diffs":[[0,"   \n    "],[-1,"*"],[0,"environ "]],"start1":1210,"start2":1210,"length1":17,"length2":16}]],"length":2142,"saved":false}
{"contributors":[],"silentsave":false,"ts":1352237633087,"patch":[[{"diffs":[[0,"KILL);\n\n"],[1,"    printf(\"spawn error %s\\n\", strerror(saved_errno));\n\n"],[0,"    errn"]],"start1":2086,"start2":2086,"length1":16,"length2":72}]],"length":2198,"saved":false}
{"ts":1352237671256,"patch":[[{"diffs":[[0," <signal.h>\n"],[1,"#include <stdio.h>\n"],[0,"#include <st"]],"start1":67,"start2":67,"length1":24,"length2":43}]],"length":2217,"saved":false}
