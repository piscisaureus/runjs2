{"ts":1348088062565,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\n#include <assert.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nextern char** environ;\nstatic int null_fd = -1;\n\n\n/* For the sake of convenience, args and env are compressed into a single string. */\n/* This function expands them to a list of pointers. */\nstatic char** expand_string(char* s) {\n  size_t num_strings, index, offset;\n  char new_string;\n  char** list;\n  \n  num_strings = 0;\n\n  for (new_string = 1, offset = 0; ; offset++) {\n    if (new_string) {\n      if (s[offset] == '\\0')\n        break;\n      num_strings++;\n      new_string = 0;\n    } else {\n      if (s[offset] == '\\0')\n        new_string = 1; \n    }\n  }\n  \n  list = calloc(sizeof(char*), num_strings + 1);\n  if (list == NULL)\n    return NULL;\n\n  index = 0;    \n  for (new_string = 1, offset = 0; ; offset++) {\n    if (new_string) {\n      if (s[offset] == '\\0')\n        break;\n      assert(index <= num_strings);\n      list[index++] = s + offset;\n      new_string = 0;\n    } else {\n      if (s[offset] == '\\0')\n        new_string = 1;\n    }\n  }\n    \n  return list;    \n}\n\n\nstatic int get_null_fd() {\n  int fd;\n  \n  if (null_fd != -1)\n    return null_fd;\n  \n  fd = open(\"/dev/null\", O_RDONLY, 0);\n  if (fd < 0)\n    return -1;\n    \n  if (ioctl(fd, FIOCLEX, NULL) < 0) {\n    close(fd);\n    return -1;\n  }\n\n  null_fd = fd;\n  return fd;\n}\n\n\nint rjs_spawn(char* file, char* args, char* env, int outfd) {\n  int err_fds[2] = { -1, -1 };\n  pid_t child_pid = 0;\n  int spawn_error, r;\n  size_t bytes_read;\n    \n  if (pipe(err_fds) < 0)\n    goto error;\n        \n  child_pid = fork();\n  if (child_pid < 0)\n    goto error;\n    \n  if (child_pid == 0) {   \n    /* We are the child. */\n    char** argv;\n    int e;\n\n    close(err_fds[0]);\n    \n    if (ioctl(err_fds[1], FIOCLEX, NULL) < 0)\n      goto error;\n    \n    if (dup2(get_null_fd(), 0) < 0)\n      goto child_error;\n     \n    if (dup2(outfd, 1) < 0)\n      goto child_error;\n      \n    if (dup2(outfd, 2) < 0)\n      goto child_error;\n    \n    argv = expand_string(args);\n    if (argv == NULL)\n      goto child_error;\n\n    environ = expand_string(env);\n    if (environ == NULL)\n      goto child_error;\n      \n    execvp(file, argv);\n\n   child_error:\n    e = errno;\n    write(err_fds[1], &e, sizeof e);\n    exit(127);\n  }\n  \n  close(err_fds[1]);\n  err_fds[1] = -1;\n  \n  spawn_error = 0;\n  bytes_read = 0;\n  \n  while (bytes_read < sizeof spawn_error) {\n    r = read(err_fds[0],\n             bytes_read + (char*) &spawn_error, \n             sizeof spawn_error - bytes_read);\n    if (r == -1 && errno == EINTR)\n      continue;\n    if (r == -1)\n      goto error;\n    if (r == 0)\n      break;\n    bytes_read += r;\n  }\n  \n  if (bytes_read == 4) {\n    errno = spawn_error;\n    goto error;\n  }\n  \n  if (r != 0)\n    goto error;\n  \n  close(err_fds[0]);\n  return child_pid;    \n\n error: {\n    int saved_errno = errno;\n  \n    if (err_fds[0] != -1)\n      close(err_fds[0]);\n    if (err_fds[1] != -1)\n      close(err_fds[1]);\n    if (child_pid > 0)\n      kill(-child_pid, SIGKILL);\n\n    errno = saved_errno;\n    return -1;  \n  }\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":3166}]],"length":3166}
