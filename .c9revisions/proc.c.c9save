{"ts":1348088062609,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\n#include \"cmd.h\"\n#include \"proc.h\"\n#include \"spawn.h\"\n\n#include <signal.h>\n#include <path.h>\n#include <errno.h>\n\n#define MAX_PROCESSES 16\n\nstatic rjs_process_t procs[MAX_PROCESSES];\nstatic struct pollfd pollfds[1 + MAX_PROCESSES];\n\nstatic size_t proc_count = 0;\n\n\nstatic size_t dup_string_list(char** s, char* target) {\n  char** pointers;\n  size_t i, sz;\n\n  \n  /* Compute the size of the pointer array */\n  sz = 0;\n  for (i = 0; s[i] != NULL; i++)\n    sz += sizeof(char*);\n  sz += sizeof(char*);\n\n  if (target != NULL) {\n    pointers = (char**) target;\n    target += sz;\n  }\n  \n  /* Compute the size of the actual strings. */\n  for (i = 0; s[i] = NULL; i++) {\n    size_t sz2 += strlen(s[i]) + 1;\n    \n    if (target != NULL) {\n      memcpy(target, s, sz2);\n      pointers[i] = target;\n      \n      target += sz2;\n      sz += sz2;\n    }\n  }\n  \n  if (target != NULL) {\n    pointers[i] = NULL;\n  }\n  \n  return sz;\n}\n\n\nstatic int rjs_proc_start(char* tag, char* file, char** args, char** env) {\n  rjs_process_t* p = NULL;\n  char* log_file = NULL;\n  char* buf[MAX_PATH];\n  int r;\n  size_t len;\n   \n  /* Generate a filename for the log file. */\n  r = snprintf(\"%s/%s.log\", sizeof buf, rjs_log_dir(), tag);\n  if (r >= sizeof buf) {\n    errno = ENAMETOOLONG;\n    return -1;\n  }\n\n  /* Compute the total size of the memory block. */\n  \n  \n  \n\n  p = malloc(sizeof *p);\n  if (p == NULL) {\n        \n  p->state = RJS_STARTING;\n  p->tag = tag;\n  p->file = file;\n  p->args = args;\n  p->env = env;\n\n  p->pid = -1;\n  p->exit_status = 0;\n  p->log_fd = -1;\n\n  \n  \n  rjs_process_state_t state;\n  char* tag;\n  char* file;\n  char* args;\n  char* env;\n  char* log_file;\n  int pid;\n  int exit_status;\n  int log_fd;\n  ngx_queue_t process_queue;  \n  \n error:\n  free(log_file);\n  free(p);\n  return -1;\n}\n\nvoid rjs_proc_free(rjs_proc_t* p) {\n  int index;\n\n  free(p->tag);\n  free(p->file);\n  free(p->env);\n  free(p->args);\n  free(p->log_file);\n\n  if (p->log_fd > 0)\n    close(p->log_fd);\n\n  index = p - procs;\n  \n  memmove(procs + index, (proc_count - index - 1) * sizeof procs[0]);\n  memmove(pollfds + index, (proc_count - index - 1) * sizeof pollfds[0]);\n  --proc_count;\n  \n  memset(&procs[proc_count), 0, sizeof procs[proc_count]);\n  procs[proc_count].state = RJS_FREE;\n}\n\n\nint rjs_proc_start(rjs_process_t* proc) {\n  int pid;\n  int log_fd = -1s;\n  \n  assert(proc->state == PROC_ALLOCATED);\n  \n  log_fd = open(proc->log_file, O_WRONLY | O_APPEND, 0666);\n  if (log_fd < 0)\n    goto error;\n    \n  if (ioctl(log_fd, FIOCLEX, NULL) < 0)\n    goto error;\n    \n  pid = rjs_spawn(proc->file, proc->args, proc->env, log_fd);\n  if (pid < 0)\n    goto error;\n    \n  proc->log_fd = log_fd;\n  proc->state = STATE_RUNNING;\n  \n  return pid;\n      \n error:\n  if (log_fd >= 0)\n    close(log_fd);\n  return -1;\n}\n\n\nint rjs_run(int server_fd) {\n  for (;;) {\n    struct pollfd pfds[1 + MAX_PROCESSES];\n    \n    pfds[0].fd = server_fd;\n    pfds[0].events = POLLIN;\n    pfds[0].revents = 0;\n    \n    poll(pfds, 1, -1);\n    \n    if (pfds[0].revents & POLLIN)\n      rjs_process_cmd(server_fd);\n      \n        \n  }    \n  \n  }\n"]],"start1":0,"start2":0,"length1":0,"length2":3072}]],"length":3072}
